---
title: "[テスト] 今よりも単体テストを良くする考え方" # 記事のタイトル
emoji: "🧪" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["テスト", "typescript", "初心者向け"] # タグ。["markdown", "rust", "aws"]のように指定する
published: true # 公開:true / 非公開:false
---

## はじめに

エンジニアとして初めて入社した PJ でテスターとして 2 年間活動しました。
その PJ でテストについての概念等を理解しました。
しかし、現在の PJ でいざテストの文化を 1 から構築する時に色々分からないことがあった為、
下記書籍で`単体テスト`について学習しました。
その内容を記録します。
@[card](https://book.mynavi.jp/ec/products/detail/id=134252)

## 1. 網羅率(coverage)のみを強く意識しない

:::message
**網羅率（coverage）とは**
全体の中でどれだけの範囲をカバーできているかを示す指標です。
何かを調査・分析したり、テストしたりする場合に、
その対象の中で網羅できた部分の割合を示します。
:::
テストパターンが十分であるかの指標の為に`網羅率(coverage)`を活用します。
しかし、網羅率(coverage)を強く意識すると逆に開発効率が悪くなり、
いつまでたってもリリースができない悪循環になる可能性があります。

例えば、下記コードに対して**入力値を 5 として返り値が`true`であること**を確認するテストパターンの場合
もちろん、網羅率は`50%`になります。(2,3 行目を通過したため)

```ts
// 単純な分岐処理
const isGreaterThanOrEqualToFive = (value: number): boolean => {
  if (value >= 5) return true;
  else return false;
};
```

しかし、
下記コードに対して同様なテストパターンの場合、網羅率は`100%`になります。(if 分岐を省略して 1 行の為)

```ts
// if文を使わずにシンプル
const isGreaterThanOrEqualToFive = (value: number): boolean => value >= 5;
```

:::message
コードの書き方によって`網羅率`を操作する事が可能である
:::

網羅率が意味がないのか？と考えるのではなく、網羅率が低すぎる状態を回避する事を意識する
さらに、分岐網羅率(branch coverage)で考える網羅率より正確に計測する事が出来る

## 2. AAA パターンでテストコードを実装する

:::message
下記英単語の頭文字を取得し`AAAパターン`とする

1. **準備(Arrange)**
   - 事前条件を満たすようにテスト対象とその依存の状態を設定する
2. **実行(Act)**
   - テスト対象の読み出し、実行を行う。また実行結果の中身の確認はここで行う
3. **確認(Assert)** - 実行結果が想定通りかを確認する
   :::

下記テストコードのようにすべてのテストケースに対して統一された構成にする

```ts
// add関数のテスト
test("AAAパターンでテストコードを実装する", () => {
  // 準備(Arrange)
  const arg01 = 1;
  const arg02 = 2;
  const expectedValue = 3;

  // 実行(Act)
  const result = sut.add(arg01, arg02);

  // 確認(Assert)
  expect(result).toBe(expectedValue);
});
```

:::message
**メリット**: コードの可読性が向上し、保守コストの低下
:::

## 3. テスト対象プログラムは、`sut`と定義する

:::message
テスト対象システム(System Under Test:SUT)は、変数名からすぐに判断できるように定義する
:::

例えば、インポート時に`as`を使って定義する

```ts
import * as sut from "./math";

// 実行(Act)
const result = sut.add(arg01, arg02);
```

## 4. テスト・メソッド名は、非開発者でも名称にする

:::message

1. **厳格な命名規則に縛られないようにする**
   - 複雑な振る舞いを厳格な命名規則に従って表現することには限界があるため、そのような命名規則を強要しない
2. **問題領域のことに精通している非開発者に対してどのような検証をするのかが伝わるように命名する** - 非開発者とはドメインエキスパートやビジネスアナリストなどを指す
   :::

例えば、下記様なテストケースの場合

- `不正な日付`がどんな不正なのか曖昧な為、`過去の日付`とわかりやすい言葉に変換したり
- `~だと見なされるべき`も曖昧な表現を避けて、`~である`と変換する

```diff
- test('不正な日付が指定された配達は不正だと見なされるべきである', () => {})
+ test('過去の日付が指定された配達は不正である', () => {})
```

※ 日本語でテストパターンが書けない場合は、ChatGTP などの AI を活用して英語に翻訳するのもあり

## 5. テストケースの作成は、`ブラックボックステスト`で考える

:::message

- **ブラックボックステスト**とは
  システムの機能をそのシステムの内部構造を知ることなしに検証するソフトウェアテストの手法のこと
  テスト対象が処理を **どのように(how)** 行うべきか、ということではなく、**何(what)** をすべきか、ということが検証される

- **ホワイトボックステスト**とは
  ブラックボックステストと逆の視点で行われる手法のこと
  仕様や要求からではなく、ソースコードから生成される
  :::

`ホワイトボックステスト`だとソースコードの細部まで配慮する事が可能のため、
`ブラックボックステスト`では検出する事が出来ない不具合を検出する事が可能である
しかし、
:::message alert
テスト対象プログラムとの結びつきが強くなるため、
小さいリファクタリングでもテストコードの改修を伴う可能性が高い -> **保守コストが増加**
:::

そのため、
保守コストを抑えるためにも、`ブラックボックステスト`でテストケースを作成し、
壊れないテストコードにする

では、`ホワイトボックステスト`の活用方法は、
`分岐網羅率(branch coverage)`の向上のために活用する

| TH                     | リファクタリングへの耐性 | 不具合の検出率 |
| ---------------------- | ------------------------ | -------------- |
| ホワイトボックステスト | 劣っている               | 優れている     |
| ブラックボックステスト | 優れている               | 劣っている     |

## 6. 良い単体テストの定義とは

:::message

1. **後退(regression)に対する保護**
2. **リファクタリングへの耐性**
3. **迅速なフィードバック**
4. **保守のしやすさ**
   :::

### 1. 後退(regression)に対する保護

- テストをする事で`デグレ`の存在をいかに検出できるのかを示す性質である
- 開発者が開発したソースコードだけではなく、使用しているライブラリーやフレームワークが多いほど効果的である

### 2. リファクタリングへの耐性

- いかに`偽陽性`を生み出すことなく、リファクタリングを行えるのかを示す性質である
  ※テスト対象プログラムは、問題ないにもかかわらず嘘のテストを通知すること

### 3. 迅速なフィードバック

- テストの実行時間をどのぐらい短くなるのかに影響する性質である

### 4. 保守のしやすさ

- 何をテストしているのかを理解することがどのくらい難しいのか？
  - テストケースのサイズが小さいほど読みやすくなる
- テストを実施することがどのくらい難しいのか？
  - 依存関係が少ないほど、テスト実施が簡単になる
